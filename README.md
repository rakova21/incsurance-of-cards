# **Программное средство страхования рисков, связанных с использованием банковских платежных карточек и электронных кошельков для физических лиц**

Программное средство предоставляет возможность формирования договора о страховании не выходя из дома, а также помогает  страховому агенту, заключающему договоры с клиентами в офисе, используя ПО значиттельно сократить время оформления, а также минимизировать риск ошибок в заполнении бланков договоров. ПС содержит информативный блок, где есть все необходимые блоки инфорамации, которые нужно знать страхователю. Также для клиента предусмотрена возможность задать оставщиеся вопросы сотруднику страховой компании в чате.

Ссылки на репозитории сервера и клиента
Сервер:https://github.com/rakova21/incsurance-of-cards-server.git
Клиент:https://github.com/rakova21/incsurance-of-cards-client.git
---

## **Содержание**

1. [Архитектура](#Архитектура)
	1. [C4-модель](#C4-модель)
	2. [Схема данных](#Схема_данных)
2. [Функциональные возможности](#Функциональные_возможности)
	1. [Диаграмма вариантов использования(#Диаграмма_вариантов_использования)]
	2. [User-flow диаграммы](#User-flow_диаграммы)
3. [Детали реализации](#Детали_реализации)
	1. [UML-диаграммы](#UML-диаграммы)
	2. [Спецификация API](#Спецификация_API)
	3. [Безопасность](#Безопасность)
	4. [Оценка качества кода](#Оценка_качества_кода)
4. [Пользовательский интерфейс](#Пользовательский интерфейс)
	1. [Примеры экранов пользовательского интерфейса](#Примеры экранов пользовательского интерфейса)
5. [Тестирование](#Тестирование)
	1. [Unit-тесты](#Unit-тесты)
	2. [Интеграционные тесты](#Интеграционные_тесты)
6. [Установка и  запуск](#installation)
	1. [Манифесты для сборки docker образов](#Манифесты_для_сборки_docker_образов)
	2. [Манифесты для развертывания k8s кластера](#Манифесты_для_развертывания_k8s_кластера)
7. [Лицензия](#Лицензия)
8. [Контакты](#Контакты)

---
## **Архитектура**

### C4-модель


<img width="551" height="784" alt="image" src="https://github.com/user-attachments/assets/993b335d-90ad-44bb-bd1c-a2b3d09e1e3f" />

Программное средство страхования рисков, связанных с использованием банковских платежных карточек и электронных кошельков для физических лиц FinShield обеспечивает взаимодействие между четырьмя основными категориями пользователей: страхователями, страховыми агентами, специалистами по договорам и системным администратором. Каждый из участников решает собственные задачи: страхователь получает доступ к информации, оформляет договоры и оплачивает их; страховой агент помогает клиентам с заполнением и формированием договоров; специалист по договорам проверяет их корректность и подтверждает актуальный статус; системный администратор управляет пользователями и настройками системы.
Система FinShield реализована с использованием нескольких ключевых контейнеров. Основой взаимодействия пользователей является клиентское приложение, которое предоставляет удобный интерфейс для работы с договорами, информационными материалами и чатом со специалистом.
Вся бизнес-логика системы сосредоточена в Backend-приложении на базе Spring Boot. Оно отвечает за обработку запросов от клиентского приложения, выполнение бизнес-правил, проверку условий страхования и управление процессами оплаты.
Хранение информации осуществляется в базе данных MySQL, которая содержит сведения о пользователях системы, договорах страхования, их статусах и операциях по оплате. Доступ к базе данных возможен исключительно через Backend, что гарантирует централизованный контроль за чтением и записью данных, а также поддержание целостности и согласованности данных в системе.

<img width="1097" height="801" alt="image" src="https://github.com/user-attachments/assets/9d0ce557-7a1c-44d4-b4d6-3a2ad473f58b" />

На компонентном уровне программное средство FinShield представлена как набор логически взаимосвязанных модулей, каждый из которых выполняет строго определённые задачи. Диаграмма отражает взаимодействие между клиентским приложением, серверной частью и базой данных. Такой подход позволяет обеспечить чёткое разделение обязанностей, прозрачность структуры и удобство сопровождения программного средства.
Клиентская часть реализована в виде веб-приложения. Она формирует пользовательский интерфейс для всех категорий участников – страхователя, страхового агента, специалиста по договорам и системного администратора. Основная её функция заключается в том, чтобы принимать ввод пользователя, отправлять запросы к серверу и отображать результаты обработки в удобной форме.
Серверная часть состоит из двух ключевых уровней – контроллеров и сервисов. Контроллеры отвечают за приём запросов от клиентского приложения и передачу их соответствующим сервисам. На диаграмме представлены следующие контроллеры: UserController, ContractController, PaymentController, ChatController, TemplateController, AdminController. Каждый из них выполняет свою задачу: от регистрации пользователей и управления договорами до обработки платежей, поддержки чата и выполнения административных функций.
Сервисы, в свою очередь, инкапсулируют бизнес-логику системы. Они содержат алгоритмы и правила работы с данными и обеспечивают выполнение ключевых операций. На диаграмме показаны следующие сервисы: UserService, ContractService, PaymentService, ChatService, TemplateService, AdminService. Например, ContractService управляет жизненным циклом договоров, PaymentService отвечает за обработку платежей и их подтверждение, а ChatService обеспечивает обмен сообщениями между пользователем и специалистом. Сервисы взаимодействуют напрямую с базой данных и предоставляют контроллерам уже готовые результаты обработки.
Центральным хранилищем данных является база данных MySQL, где сохраняется информация обо всех пользователях, договорах, платежах, шаблонах документов, истории переписки и статусах. Взаимодействие с базой данных осуществляется только через сервисы, что гарантирует целостность и согласованность информации.


### Схема данных

На рисунке представлена физическая модель базы данных.

<img width="733" height="801" alt="image" src="https://github.com/user-attachments/assets/4b95a31a-9d5a-4ee3-9de6-98ca5ce49b3e" />




---

## **Функциональные возможности**

### Диаграмма вариантов использования

Диаграмма вариантов использования и ее описание

### User-flow диаграммы

User-flow диаграмма для роли «Системный администратор» представлена на рисунке 1.

<img width="992" height="771" alt="image" src="https://github.com/user-attachments/assets/ee82cc74-85f0-4621-bc2f-88210728a7ec" />

Рисунок 1 – User-flow диаграмма для роли «Системный администратор»

User-flow диаграмма для роли «Системный администратор» отражает последовательность действий, связанных с управлением пользователями в программном средстве страхования рисков, возникающих при использовании банковских платежных карточек и электронных кошельков. Задачей пользователя, авторизированного под данной ролью является выполнение административных функций, связанных с изменением ролей, блокировкой, разблокировкой и удалением учетных записей.
Диаграмма включает два крупных процесса: регистрацию и вход в систему, а также управление пользователями. На первом этапе пользователь либо регистрируется, если ранее не имел учетной записи, либо проходит процедуру входа в систему. При регистрации необходимо ввести свою фамилию, имя и отчество, другие персональные данные, и, наконец, логин и пароль. После заполнения система проверяет корректность введенной информации. Если данные заполнены верно, создается новая учетная запись, и пользователь может войти в систему. В случае, если пользователь уже зарегистрирован, он вводит логин и пароль для авторизации, и при успешной проверке данных получает доступ к интерфейсу системы.
После входа системный администратор получает доступ к функциям управления пользователями. В этой части диаграммы представлены действия, связанные с просмотром списка пользователей. Администратор может выбрать конкретного пользователя и изменить его роль в системе, при необходимости временно заблокировать или, наоборот, разблокировать доступ к учетной записи. Кроме того, предусмотрена возможность полного удаления пользователя из базы данных системы. Все операции требуют подтверждения, что обеспечивает контроль действий и предотвращает случайные изменения.
В результате реализации описанного процесса обеспечивается поддержание актуальности данных о пользователях системы, контроль над доступом к функциональным возможностям и безопасностью работы программного средства. Системный администратор выполняет ключевую роль в обеспечении корректной работы системы и управлении пользовательскими учетными записями, гарантируя надежность и защищенность программного продукта.
На рисунке 2 отображена user-flow диаграмма для роли «Страхователь».

 <img width="864" height="765" alt="image" src="https://github.com/user-attachments/assets/5424f96d-ad3b-40b0-8d1a-8750fbcd6331" />

Рисунок 2 – User-flow диаграмма для роли «Страхователь»

User-flow диаграмма, представленная для роли «Страхователь», демонстрирует логику взаимодействия клиента с программным средством. Основное назначение этой схемы – показать, каким образом пользователь проходит путь от регистрации до оформления и оплаты страхового договора, а также как он может получать информационную поддержку.
Регистрация и вход проходит аналогично у всех ролей.
После входа страхователь получает возможность работать с несколькими функциональными разделами. Один из них – информационный, предназначенный для взаимодействия с сотрудниками страховой компании. Пользователь может задать вопрос, получить ответ и при необходимости уточнить дополнительные детали. Такой механизм делает систему не просто средством оформления договоров, а полноценным инструментом консультирования и сопровождения клиента.
Другой функциональный блок связан с управлением персональной информацией. Здесь страхователь может просмотреть свой профиль, при необходимости скорректировать личные данные и сохранить изменения. Система проверяет корректность введенной информации, что позволяет поддерживать достоверность сведений и предотвращает ошибки при дальнейшем оформлении документов.
Отдельное внимание в диаграмме уделено процессу работы с объектами страхования. Пользователь может просматривать существующие объекты или добавить новые – например, указать данные банковской карты или электронного кошелька, которые подлежат страхованию. После заполнения соответствующих полей система проверяет правильность введенной информации и сохраняет объект.
Ключевой бизнес-процесс – заключение страхового договора. Страхователь выбирает страхуемый объект, вводит необходимые данные для договора и отправляет заявку. После проверки данных менеджером система уведомляет пользователя о статусе заявки. В случае положительного решения страхователь переходит к оплате услуги. Оплата может осуществляться различными способами, предусмотренными системой, а после подтверждения платежа договор получает статус «Оплачен».
Кроме того, система предоставляет пользователю возможность просматривать справочную информацию – перечень доступных видов страхования, условия услуг, ответы на часто задаваемые вопросы. Это помогает страхователю лучше ориентироваться в возможностях программы и самостоятельно принимать решения.
В целом, диаграмма последовательность действий, позволяющую пользователю без лишних сложностей заключить страховой договор. Процесс охватывает все ключевые аспекты взаимодействия – от первичной регистрации и консультаций до формирования и оплаты договора.
Далее на рисунке 3 представлена user-flow диаграмма для роли «Специалист по договорам».

<img width="896" height="682" alt="image" src="https://github.com/user-attachments/assets/0d883c42-f4d5-49d8-9e6a-959601f77ba4" />

Рисунок 3 – User-flow диаграмма для роли «Специалист по договорам»

Диаграмма для роли «Специалист по договорам» описывает процесс работы сотрудника страховой компании, отвечающего за проверку, утверждение и сопровождение договоров страхования. Основная задача данной роли заключается в обеспечении корректности данных, внесённых страхователе, контроле статусов договоров, а также взаимодействии с клиентами через систему.
Работа специалиста начинается аналогично предыдущим ролям с авторизации. 
Одним из направлений работы является управление информационным контентом для страхователей. Специалист может просматривать существующие информационные блоки, вносить правки и сохранять обновления. Это позволяет поддерживать актуальность представленных сведений о страховых продуктах, тарифах и условиях заключения договоров. Благодаря этому пользователи системы получают достоверную и своевременную информацию.
Другой важный процесс, который является одним из ключевых, отражает контроль состояния договоров. Специалист просматривает оформленные договоры страхования и проверяет, была ли произведена их оплата. Если договор оплачен, сотрудник меняет его статус на «Готов к подписанию» и формирует окончательную версию страхового документа. 
Еще одним из ключевых процессов является работа с заявками на страхование. Специалист получает доступ к списку заявок, поданных страхователями, и проверяет корректность внесённых данных. В случае ошибок он может оставить комментарии, указывая на найденные неточности. Если данные верны, специалист вносит недостающие данные и формирует окончательный договор и присваивает ему соответствующий статус.
Последний функциональный блок диаграммы связан с обратной связью с клиентами. Специалист имеет возможность просматривать поступившие от страхователей вопросы и оставлять на них ответы. Таким образом, он выполняет и консультационную функцию, обеспечивая оперативное взаимодействие между страховой компанией и пользователями.
Данная роль является связующим звеном между системой, страхователями и страховыми агентами, гарантируя корректное оформление и сопровождение договоров на всех этапах их существования.
User-flow диаграмма для роли «Страховой агент» представлена на рисунке 4.

 <img width="878" height="763" alt="image" src="https://github.com/user-attachments/assets/33168ce1-355a-40ba-af0f-c2bf28dfa113" />

Рисунок 4 – User-flow диаграмма для роли «Страховой агент»
User-flow для роли «Страховой агент» иллюстрирует последовательность действий сотрудника страховой компании, который непосредственно занимается оформлением и сопровождением договоров страхования в офисе. 
Начало работы страхового агента, как и у других пользователей, начинается с авторизации. После успешного входа система предоставляет доступ ко всем инструментам, необходимым для выполнения его профессиональных обязанностей.
Первое направление работы агента – просмотр заключённых договоров. В интерфейсе программы агент может открыть список ранее оформленных договоров, просмотреть их параметры и статусы, проверить сроки действия, суммы страховых выплат и данные клиентов. 
Главный функциональный блок диаграммы – оформление нового страхового договора. Процесс начинается с выбора команды «Начать формирование договора». Далее агент вносит все необходимые сведения: данные клиента, объект страхования, период действия, условия и размер страховой суммы и проверяет правильность заполненных полей. Если данные введены корректно, формируется договор для подписания обеими сторонами – страховой компанией и страхователем. После этого агент сохраняет документ и присваивает ему статус «Заключён». Поскольку оформление договора происходит в присутствии клиента, такие договоры сразу считаются оплаченными.
Для структурированного, четкого и актуального информирования клиентов агент имеет доступ к информационному разделу. Здесь он может просматривать актуальные сведения о страховых продуктах, тарифах, сроках и условиях. Иформационный блок выступает не только справочным ресурсом, но и инструментом повышения качества обслуживания.
В совокупности все процессы, представленные на диаграмме, формируют логичную и завершённую схему деятельности страхового агента. Такая организация работы способствует повышению доверия к страховой компании и оптимизирует процесс взаимодействия с пользователями.


---

## **Детали реализации**

### UML-диаграммы

Представить все UML-диаграммы , которые позволят более точно понять структуру и детали реализации ПС

### Спецификация API

Представить описание реализованных функциональных возможностей ПС с использованием Open API (можно представить либо полный файл спецификации, либо ссылку на него)

### Безопасность

Аутентификация. Аутентификация – это процесс подтверждения личности пользователя, при котором система проверяет правильность введённых логина и пароля. После успешной проверки создаётся JWT-токен (JSON Web Token), который пользователь отправляет в каждом запросе к серверу для подтверждения своей личности. Такой подход избавляет от необходимости повторной проверки логина и пароля при каждом обращении и обеспечивает безопасное взаимодействие между клиентом и сервером.
В разрабатываемом проекте аутентификация реализована с использованием фреймворка Spring Security и технологии JWT, обеспечивающих безопасное хранение и проверку данных пользователей.
Аутентификация реализована при помощи следующих классов: AuthController, AuthService, JwtProvider, SecurityConfiguration, а также классы пользовательской модели – AppUser, MyUserPrincipal и UserToUserDtoConverter.
Контроллер AuthController обрабатывает запросы на вход в систему по маршруту /users/login. После успешной аутентификации он формирует ответ, содержащий сведения о пользователе и выданный JWT-токен. Запрос к этому контроллеру проходит через механизм Spring Security, который проверяет логин и пароль пользователя, используя внутренние компоненты фреймворка.
Класс AuthService реализует логику формирования данных, возвращаемых при входе. Он получает информацию о пользователе из объекта Authentication, преобразует сущность AppUser в DTO с помощью конвертера UserToUserDtoConverter и вызывает метод createToken() из компонента JwtProvider. Результатом работы сервиса является JSON-объект, содержащий сведения о пользователе и токен, который впоследствии будет использоваться клиентом при взаимодействии с защищёнными эндпоинтами.
Компонент JwtProvider отвечает за создание и подпись JWT-токена. Он использует сторонние средства библиотеки Spring Security OAuth2 JWT, а именно классы JwtEncoder и JwtEncoderParameters. При генерации токена формируется набор данных (claims), содержащий имя пользователя, роли и срок действия токена. Токен подписывается с использованием пары RSA-ключей, что гарантирует его защиту от подделки и обеспечивает безопасный обмен данными между клиентом и сервером.
Конфигурационный класс SecurityConfiguration задаёт параметры безопасности всего приложения. Он определяет использование JWT как механизма аутентификации, отключает сессии и CSRF-защиту, настраивает CORS-политику и указывает алгоритм шифрования паролей (BCryptPasswordEncoder). Таким образом, он обеспечивает корректную интеграцию Spring Security с JWT и настройку всех фильтров безопасности.
В совокупности эти классы реализуют процесс аутентификации:
1	Пользователь вводит логин и пароль.
2	Система проверяет данные.
3	Генерируется JWT-токен.
4	Токен передаётся клиенту для дальнейших запросов. 
Такой механизм обеспечивает безопасный доступ к системе без сохранения сессий и минимизирует риски компрометации данных.
Авторизация. Авторизация – это процесс проверки прав пользователя на выполнение определённых действий в системе. Она определяет, имеет ли конкретный пользователь доступ к тому или иному ресурсу или функции приложения. В данном проекте авторизация основана на ролях пользователей, которые содержатся в JWT-токене и обрабатываются Spring Security при каждом запросе к защищённым эндпоинтам.
За механизм авторизации отвечают классы SecurityConfiguration, JwtProvider, MyUserPrincipal, CustomBearerTokenAuthenticationEntryPoint и CustomBearerTokenAccessDeniedHandler.
Класс SecurityConfiguration задаёт основные правила авторизации и определяет политику доступа к ресурсам. Здесь настраивается механизм проверки JWT-токенов, задаются фильтры безопасности, политика сессий и обработчики ошибок авторизации. С помощью JwtAuthenticationConverter система получает список ролей пользователя из токена и сопоставляет их с требуемыми правами для доступа к конкретным методам.
Компонент JwtProvider формирует токен, в который записываются роли пользователя в виде параметра authorities. При каждом запросе Spring Security автоматически декодирует токен, извлекает эти роли и определяет уровень доступа. Это позволяет гибко управлять разрешениями в системе без постоянного обращения к базе данных.
Класс MyUserPrincipal связывает данные о пользователе с контекстом безопасности Spring. Он передаёт список ролей (GrantedAuthority) из сущности AppUser в механизм безопасности, что позволяет системе корректно определять, какие действия разрешены конкретному пользователю.
Дополнительные компоненты – CustomBearerTokenAuthenticationEntryPoint и CustomBearerTokenAccessDeniedHandler – обеспечивают корректную обработку ошибок при авторизации. Первый отвечает за реакцию системы, когда пользователь пытается получить доступ без действительного токена (возвращает ошибку 401 Unauthorized). Второй используется, когда у пользователя недостаточно прав для выполнения действия (ошибка 403 Forbidden). Эти классы интегрированы в конфигурацию безопасности и обеспечивают информативные и безопасные ответы на стороне клиента.
В результате все перечисленные компоненты формируют надёжную систему авторизации, в которой доступ к методам и данным строго контролируется на основе ролей пользователей, указанных в токене. Механизм построен на основе стандартных компонентов Spring Security и расширен собственными обработчиками для повышения удобства и безопасности работы приложения.
Сторонние компоненты. Для реализации аутентификации и авторизации также используются различные сторонние компоненты, предоставляемые фреймворком Spring Security и библиотекой Spring Security OAuth2 JWT, обеспечивающие комплексную систему безопасности приложения. Эти инструменты предоставляют готовую инфраструктуру для управления пользователями, проверки учетных данных, разграничения прав доступа и защиты конфиденциальной информации.
Фреймворк Spring Security является центральным компонентом системы безопасности. Он отвечает за обработку запросов, проверку подлинности пользователей, применение фильтров безопасности и проверку ролей.
Основная настройка выполняется в конфигурационном классе SecurityConfiguration, который аннотирован как @Configuration и @EnableWebSecurity. В нём определяется политика безопасности всего приложения:
1	Включение и настройка JWT-аутентификации.
2	Отключение сессий и CSRF-защиты (так как используется stateless-архитектура).
3	Настройка CORS-политики.
4	Создание бина для безопасного шифрования паролей.
Для безопасного хранения паролей применяется компонент PasswordEncoder, а именно реализация BCryptPasswordEncoder, которая выполняет хэширование паролей перед их сохранением в базу данных. Это гарантирует, что даже при компрометации базы злоумышленник не сможет получить исходные пароли.
Пример кода настройки шифрования паролей приведен ниже.

@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder(12);
}

Шифрование применяется в сервисном слое при регистрации нового пользователя. В классе UserService перед сохранением в базу данных пароль преобразуется в хэш. Отрывок кода для преобразования приведен далее.

public AppUser save(AppUser user) {
    if (repository.findByUsername(user.getUsername()).isPresent()) {
        throw new BadRequestException("Пользователь с таким логином уже существует");
    }
    user.setPassword(passwordEncoder.encode(user.getPassword()));
    if (findAll().isEmpty()) {
        user.setRole(Role.ADMIN);
    }
    return repository.save(user);
}
При аутентификации Spring Security автоматически сравнивает введённый пароль с хранимым хэшем, используя метод passwordEncoder.matches().
Для реализации токен-базированной аутентификации (JWT) в проекте используется компонент из библиотеки Spring Security OAuth2 JWT, обеспечивающий создание и проверку JSON Web Token.
Компонент JwtProvider отвечает за формирование токена доступа. Он использует внешний класс JwtEncoder из пакета org.springframework.security.oauth2.jwt для генерации и подписи токена с помощью RSA-ключей. В процессе формирования в токен добавляются ключевые данные – имя пользователя, срок действия и роли (authorities), определяющие права доступа.
Ниже приведен фрагмент кода, реализующий генерацию токена.

public String createToken(Authentication authentication) {
    Instant now = Instant.now();
    long expiresIn = 2;

    String authorities = authentication.getAuthorities().stream()
            .map(GrantedAuthority::getAuthority)
            .collect(Collectors.joining(" "));

    JwtClaimsSet claims = JwtClaimsSet.builder()
            .issuer("self")
            .issuedAt(now)
            .expiresAt(now.plus(expiresIn, ChronoUnit.HOURS))
            .subject(authentication.getName())
            .claim("authorities", authorities)
            .build();

    return jwtEncoder.encode(JwtEncoderParameters.from(claims)).getTokenValue();
}

В данном фрагменте используется сторонний компонент JwtEncoder, который не только создаёт токен, но и шифрует его, подписывая приватным ключом. Благодаря этому клиент получает безопасный токен, а сервер может гарантировать его подлинность.
Компонент AuthService вызывает этот метод при успешной аутентификации пользователя, а контроллер AuthController возвращает токен клиенту в ответ на запрос /users/login. Таким образом, после прохождения проверки логина и пароля клиент получает уникальный JWT-токен, который прикладывает к каждому запросу для доступа к защищённым ресурсам.
Кроме токенов и шифрования паролей, в проекте реализованы дополнительные механизмы защиты.
Во-первых, применяется разграничение прав доступа с помощью аннотации @Secured. Контроллеры, такие как UserController, используют эту аннотацию для ограничения вызова методов в зависимости от роли пользователя.
Пример реализации разграничения прав приведен ниже.

@Secured({ADMIN})
@GetMapping("/all")
public Result findAll() {
    return new Result(
            true,
            StatusCode.SUCCESS,
            "Success Find All",
            service.findAll().stream().map(toDtoConverter::convert).collect(Collectors.toList())
    );
}

@Secured({ADMIN, MANAGER, USER})
@GetMapping
public Result find() {
    return new Result(
            true,
            StatusCode.SUCCESS,
            "Success Find",
            toDtoConverter.convert(service.getCurrentUser())
    );
}

Таким образом, только пользователи с определённой ролью (например, ADMIN) могут вызывать административные методы, тогда как обычные пользователи имеют ограниченные права.
	Для повышения надёжности системы и корректного информирования клиента при ошибках авторизации используются собственные обработчики исключений – CustomBearerTokenAuthenticationEntryPoint и CustomBearerTokenAccessDeniedHandler.
Они перехватывают ситуации, когда токен недействителен или у пользователя недостаточно прав, и возвращают соответствующие HTTP-статусы (401 Unauthorized или 403 Forbidden).
Фрагмент реализации обработчика представлен далее.

@Component
public class CustomBearerTokenAuthenticationEntryPoint implements AuthenticationEntryPoint {

    private final HandlerExceptionResolver resolver;

    public CustomBearerTokenAuthenticationEntryPoint(@Qualifier("handlerExceptionResolver") HandlerExceptionResolver resolver) {
        this.resolver = resolver;
    }

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) {
        resolver.resolveException(request, response, null, authException);
    }
}
Такие компоненты обеспечивают корректную обработку ошибок безопасности и предотвращают утечку лишней информации в ответах сервера.
Совокупное применение этих компонентов обеспечивает устойчивую, безопасную и масштабируемую систему аутентификации и авторизации, защищающую приложение от несанкционированного доступа и обеспечивающую надёжную работу с пользовательскими данными.


### Оценка качества кода

Используя показатели качества и метрики кода, оценить его качество

## **Пользовательский интерфейс**

### Примеры экранов пользовательского интерфейса

Экран «Главная» для всех пользователей программного средства страхования рисков, связанных с использованием банковских платежных карточек и электронных кошельков представлен на рисунке 1.

 <img width="624" height="317" alt="image" src="https://github.com/user-attachments/assets/1616b110-29c7-427c-ae9c-2d30f0192a29" />


Рисунок 1 – Экран «Главная» для всех пользователей программного средства

	На рисунке 2 представлен экран «Вход».

 <img width="624" height="314" alt="image" src="https://github.com/user-attachments/assets/5cb93b0e-b4a6-4807-b864-c73b2b4036d5" />


Рисунок 2 – Экран «Вход» 

	На рисунке 3 представлен экран «Регистрация».

 <img width="624" height="314" alt="image" src="https://github.com/user-attachments/assets/0f6bc0e8-962b-43da-bd29-4f0570feb7ca" />


Рисунок 3 – Экран «Регистрация» 

	На рисунке 4 представлен экран «Типы страхования» для ролей страхователя, специалиста по договорам и системного администратора.

 <img width="624" height="314" alt="image" src="https://github.com/user-attachments/assets/1925b754-35a7-45d6-a01d-09f8078a2ac8" />


Рисунок 4 – Экран «Типы страхований» для оператора сервиса для ролей страхователя, специалиста по договорам и страхового агента

	На рисунке 5 представлен экран «Типы страхований» для системного администратора.

 <img width="624" height="317" alt="image" src="https://github.com/user-attachments/assets/5a7e6f30-27b6-4572-8e8c-9b10f4a0dd66" />


Рисунок 5 – Экран «Типы страхований» для системного администратора

	На рисунке 6 представлен экран «Инструкции» для ролей страхователя, специалиста по договорам и системного администратора.

<img width="624" height="312" alt="image" src="https://github.com/user-attachments/assets/54ae4fb5-7047-4c84-aad0-b1c9d8db7f81" />

 
Рисунок 6 – Экран «Инструкции» для оператора сервиса для ролей страхователя, специалиста по договорам и страхового агента

	На рисунке 7 представлен экран «Инструкции» для системного администратора.

<img width="624" height="313" alt="image" src="https://github.com/user-attachments/assets/09a507bf-2043-4f48-9e39-33f91d0cb284" />


Рисунок 7 – Экран «Инструкции» для системного администратора

	На рисунке 8 представлен экран «Аналитика» для системного администратора.
 
<img width="624" height="317" alt="image" src="https://github.com/user-attachments/assets/28f74cc5-0135-4568-9815-c5593d5d0260" />


Рисунок 8 – Экран «Аналитика» для системного администратора

	На рисунке 9 представлен экран «Категории» для системного администратора.

 <img width="624" height="313" alt="image" src="https://github.com/user-attachments/assets/83dea1ac-e7b2-48df-861a-d64aa4d9d662" />


Рисунок 9 – Экран «Категории» для системного администратора

	На рисунке 10 представлен экран «Пользователи» для системного администратора.

 <img width="624" height="310" alt="image" src="https://github.com/user-attachments/assets/bb46e20c-feb6-4eb8-8889-667b4569a910" />


Рисунок 10 – Экран «Пользователи» для системного администратора

	На рисунке 11 представлен экран «Заявка» для страхователя.

 <img width="624" height="319" alt="image" src="https://github.com/user-attachments/assets/a4cc9704-cf95-4ce3-856c-a10a32dc5eae" />


Рисунок 11 – Экран «Заявка» для страхователя

	На рисунке 12 представлен экран «Оформить заявку» для страхователя.

 <img width="624" height="316" alt="image" src="https://github.com/user-attachments/assets/30127e83-9f53-49aa-8ea8-3e10c62e33fa" />


Рисунок 12 – Экран «Оформить заявку» для страхователя

	На рисунке 13 представлен экран «Профиль» для страхователя.

 <img width="624" height="312" alt="image" src="https://github.com/user-attachments/assets/69882fe2-999e-40f7-961d-3e31538e785e" />


Рисунок 13 – Экран «Профиль» для страхователя

	На рисунке 14 представлен экран «Оформить заявку» для страхового агента.

 <img width="624" height="318" alt="image" src="https://github.com/user-attachments/assets/9c8a60d9-354b-432d-9aa5-f7455bdc672a" />


Рисунок 14 – Экран «Оформить заявку» для страхового агента

На рисунке 15 представлен экран «Заявка» для специалиста по договорам.

 <img width="624" height="311" alt="image" src="https://github.com/user-attachments/assets/a03afe4d-8c9e-4056-9732-c097bdcaef50" />


Рисунок 15 – Экран «Заявка» для специалиста по договорам

На рисунке 16 представлен экран «Заявки» для специалиста по договорам.

 <img width="624" height="314" alt="image" src="https://github.com/user-attachments/assets/147f7df8-d16c-42a9-a6e5-570eb64a5ccc" />


Рисунок 16 – Экран «Заявки» для специалиста по договорам


---

## **Тестирование**

### Unit-тесты

Представить код тестов для пяти методов и его пояснение

### Интеграционные тесты

Представить код тестов и его пояснение

---

## **Установка и  запуск**

### Манифесты для сборки docker образов

Представить весь код манифестов или ссылки на файлы с ними (при необходимости снабдить комментариями)

### Манифесты для развертывания k8s кластера

Представить весь код манифестов или ссылки на файлы с ними (при необходимости снабдить комментариями)

---

## **Лицензия**

Этот проект лицензирован по лицензии MIT - подробности представлены в файле [[License.md|LICENSE.md]]

---

## **Контакты**

Автор: katya.rkv.21@gmail.com
